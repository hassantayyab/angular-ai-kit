---
description: Complete rules for Angular AI Kit - Angular v21 component library for AI chat interfaces
alwaysApply: true
---

# Angular AI Kit - Cursor Rules

You are an expert Angular developer with a passion for building scalable and maintainable Angular applications.

## Project Context

This is an **Angular v21** component library focused on AI chat interfaces. We're building standalone, signal-first components with **Tailwind CSS v4** styling.

**CRITICAL: We are using Angular v21 and Tailwind CSS v4**

- Angular v21 is the LATEST version with all modern features
- Tailwind v4 uses NEW @tailwindcss/postcss plugin (not the old tailwindcss plugin)
- We are creating a component library for Angular AI chat interfaces. Therefore, write code that is best suited for such library.
- AI assistants often make mistakes with latest versions - ALWAYS verify against official docs
- Please refer to the PLAN.md file for the project scope and requirements. Please note that this is only for reference and not to be followed blindly. Feel free to improve the plan and add more tasks as you see fit when working on a particular phase and add these tasks to the TODO.md file.

**Project Scope:**

- Build AI-focused UI components for Angular v21
- Components must be standalone, signal-based, and zoneless-compatible
- No tests required (unit, e2e, or any testing)
- Focus only on Phase 0 components (15 components total)

**Tech Stack:**

- **Angular:** v21 (latest features)
- **Tailwind CSS:** v4 (with @tailwindcss/postcss)
- **Nx:** Latest monorepo tooling
- **TypeScript:** Latest with strict mode
- **CSS ONLY** (NO SCSS)

**Monorepo:** This project uses Nx for monorepo management. Reference: [Nx Angular Documentation](https://nx.dev/docs/technologies/angular)

## Core Principles: Scalability & Maintainability

**This library must be SCALABLE and MAINTAINABLE for long-term success.**

### Scalability Principles

1. **Component Composition Over Inheritance**
   - Use `hostDirectives` for cross-cutting concerns
   - Prefer composition patterns over complex inheritance hierarchies
   - Keep components small and focused (single responsibility)

2. **Module Boundaries & Dependency Management**
   - Enforce strict module boundaries in Nx
   - Prevent circular dependencies
   - Use DI tokens for extensibility (don't hardcode implementations)
   - Keep libraries loosely coupled

3. **Performance from Day One**
   - OnPush change detection everywhere
   - Minimize signal computations (avoid nested computed signals)
   - Lazy load when possible
   - Tree-shakable exports (use barrel exports carefully)

4. **API Design**
   - Design public APIs with backwards compatibility in mind
   - Use semantic versioning
   - Deprecate gracefully (don't break existing users)
   - Keep internal APIs private (use TypeScript private/protected)

### Maintainability Principles

1. **Code Organization**
   - Maximum 500 lines per file (refactor if larger)
   - Group related functionality into feature folders
   - Clear separation: components / directives / services / types / utils
   - Consistent file naming: `feature-name.component.ts`, `feature-name.service.ts`

2. **Type Safety**
   - TypeScript strict mode enabled
   - No `any` types (use `unknown` if truly needed)
   - Use discriminated unions for complex types
   - Define clear interfaces for all public APIs

3. **Documentation**
   - JSDoc comments for all public APIs
   - Include usage examples in comments
   - Document complex logic with inline comments
   - Keep README and PLAN.md up to date

4. **Consistency**
   - Follow established patterns (don't invent new ones unnecessarily)
   - Use shared utilities from `@angular-ai-kit/utils`
   - Consistent naming conventions throughout
   - Automated formatting with Prettier

5. **Error Handling**
   - Fail gracefully with user-friendly messages
   - Log errors appropriately (but remove before production)
   - Provide fallback UI states
   - Don't swallow errors silently

6. **Testability (Future Consideration)**
   - Write components to be testable (even if no tests now)
   - Avoid tight coupling
   - Use dependency injection
   - Keep business logic separate from UI logic

## TypeScript Best Practices

- Use strict type checking
- Prefer type inference when the type is obvious
- Avoid the `any` type; use `unknown` when type is uncertain
- Use meaningful variable and function names
- Use interfaces for type definitions
- Use optional chaining and nullish coalescing
- Validate inputs when necessary
- No console.logs or debug code
- Handle edge cases gracefully
- Provide meaningful error messages

## Angular v21 Best Practices

**IMPORTANT: This project uses Angular v21 (the LATEST version).**

- Always use standalone components over NgModules
- Must NOT set `standalone: true` inside Angular decorators. It's the default in Angular v20+.
- Use signals for state management
- Use signal-based inputs/outputs (`input()`, `output()`, `computed()`, `effect()`)
- Use OnPush change detection strategy
- Use new control flow syntax (`@if`, `@for`, `@switch`) instead of `*ngIf`, `*ngFor`, `*ngSwitch`
- Prefer signals over observables when possible
- Make components zoneless-compatible
- Use `provideExperimentalZonelessChangeDetection()` in providers
- Implement lazy loading for feature routes
- Do NOT use the `@HostBinding` and `@HostListener` decorators. Put host bindings inside the `host` object of the `@Component` or `@Directive` decorator instead
- Use `NgOptimizedImage` for all static images
  - `NgOptimizedImage` does not work for inline base64 images
- Do NOT use `ngClass`, use `class` bindings instead
- Do NOT use `ngStyle`, use `style` bindings instead
- When using external templates/styles, use paths relative to the component TS file
- Prefer inline templates for small components
- Prefer Reactive forms instead of Template-driven ones
- All components MUST be SSR/hydration compatible (no direct DOM manipulation)
- **ALWAYS use CSS, NEVER use SCSS**

## Component Structure

```typescript
import {
  Component,
  ChangeDetectionStrategy,
  ViewEncapsulation,
  computed,
  input,
  output,
  signal,
  inject,
} from '@angular/core';
import { cn } from '@angular-ai-kit/utils';

@Component({
  selector: 'ai-component-name',
  // standalone is default in Angular v20+, don't set it explicitly
  imports: [
    /* only what's needed */
  ],
  changeDetection: ChangeDetectionStrategy.OnPush,
  encapsulation: ViewEncapsulation.None, // Required for Tailwind
  template: `
    <div [class]="containerClasses()">
      <!-- Content -->
    </div>
  `,
  styles: [
    `
      /* Use CSS only, not SCSS */
      /* Minimal styles - prefer Tailwind classes */
    `,
  ],
  // Use host object instead of @HostBinding/@HostListener
  host: {
    '[class]': 'hostClasses()',
    '[attr.aria-label]': 'ariaLabel()',
    '(click)': 'handleClick()',
    '(keydown.enter)': 'handleEnter()',
  },
})
export class ComponentName {
  // Use inject() function instead of constructor injection
  private service = inject(SomeService);
  private document = inject(DOCUMENT); // For DOM access (SSR-safe)

  // Inputs (with transforms if needed)
  prop = input.required<Type>();
  optionalProp = input<Type>(defaultValue);
  customClasses = input<string>(''); // Allow class override

  // Input transforms (for type coercion)
  disabled = input(false, {
    transform: (value: boolean | string) => value === '' || value === true,
  });

  // Outputs
  event = output<Type>();

  // Computed signals (dynamic classes, derived state)
  containerClasses = computed(() => {
    return cn(
      'ai-component-base',
      { 'ai-component-disabled': this.disabled() },
      this.customClasses()
    );
  });

  hostClasses = computed(() => 'ai-component-wrapper');

  // Regular signals (local state)
  state = signal<Type>(initialValue);

  // Effects (minimize usage)
  constructor() {
    effect(() => {
      // Only for side effects, not for computed values
      const value = this.prop();
      // React to changes
    });
  }

  // Methods
  handleClick() {
    this.event.emit(/* data */);
  }

  handleEnter() {
    // Keyboard accessibility
  }
}
```

## Services

- Design services around a single responsibility
- Use the `providedIn: 'root'` option for singleton services
- Use the `inject()` function instead of constructor injection

```typescript
// Use inject() function instead of constructor injection
export class ComponentName {
  private service = inject(SomeService);
  private config = inject(APP_CONFIG);
}
```

## State Management

- Use signals for local component state
- Use `computed()` for derived state
- Keep state transformations pure and predictable
- Do NOT use `mutate` on signals, use `update` or `set` instead
- Minimize effect() usage
- **Component Library**: Keep state-management agnostic - components should not depend on NgRx or other state management libraries
- **Demo App (Optional)**: Consider NgRx Signal Store for application-level state management if needed

### Signal Patterns

```typescript
// Signal-based Inputs
message = input.required<ChatMessage>();
speed = input(30); // with default

// Computed Values
containerClasses = computed(() => {
  const base = 'flex gap-3';
  return `${base} ${this.message().role === 'user' ? 'bg-muted' : 'bg-background'}`;
});

// Effects
constructor() {
  effect(() => {
    const value = this.input();
    // React to changes
  });
}

// Signal Updates - ❌ Don't use mutate
this.state.mutate((value) => {
  value.property = newValue;
});

// ✅ Use update or set instead
this.state.update((value) => ({
  ...value,
  property: newValue,
}));
// or
this.state.set({ ...this.state(), property: newValue });
```

## Templates

- Keep templates simple and avoid complex logic
- Use native control flow (`@if`, `@for`, `@switch`) instead of `*ngIf`, `*ngFor`, `*ngSwitch`
- Use the async pipe to handle observables
- Do not assume globals like `new Date()` are available
- Do not write arrow functions in templates (they are not supported)
- Use `class` bindings instead of `ngClass`
- Use `style` bindings instead of `ngStyle`

## Styling Guidelines (Tailwind CSS v4)

**IMPORTANT: This project uses Tailwind CSS v4, not v3. The setup is DIFFERENT.**

### Tailwind v4 Setup

- Uses **@tailwindcss/postcss** plugin (NOT the old tailwindcss plugin)
- Uses `.postcssrc.json` for PostCSS configuration
- Uses `@import "tailwindcss"` in CSS files (NOT @tailwind directives)
- Uses `@source` directive to watch files in monorepo
- No `tailwind.config.js` needed (uses CSS-based configuration)

### Styling Rules

- Use Tailwind CSS utility classes for ALL styling (utility-first approach)
- Use CSS only (NOT SCSS) for any necessary custom styles
- Use `clsx` and `tailwind-merge` for dynamic classes (via `cn()` utility)
- Use `ViewEncapsulation.None` with scoped Tailwind classes
- Use CSS custom properties (CSS variables) for theming
- Use `@layer` directives in CSS files (base, components, utilities)
- Keep styles in template or inline styles array (avoid separate CSS files unless necessary)
- Ensure responsive design (mobile-first approach)
- Support dark mode via CSS variables and `prefers-color-scheme`
- Maintain consistent spacing and sizing using design tokens
- Use Tailwind class sorting plugin for consistency

### Tailwind v4 CSS Structure

```css
/* styles.css */
@import 'tailwindcss';

/* Watch monorepo packages for Tailwind classes */
@source '../../packages';

/* Theme configuration using CSS */
@layer base {
  :root {
    --color-primary: #3b82f6;
    --color-background: #ffffff;
  }

  .dark {
    --color-primary: #60a5fa;
    --color-background: #1f2937;
  }
}

@layer components {
  .ai-button {
    @apply rounded-lg bg-blue-500 px-4 py-2 text-white;
  }
}
```

**References:**

- [Tailwind CSS v4 Angular Guide](https://tailwindcss.com/docs/installation/framework-guides/angular)
- [Nx + Tailwind CSS Guide](https://nx.dev/docs/technologies/angular/guides/using-tailwind-css-with-angular-projects)

### View Encapsulation Pattern

```typescript
@Component({
  selector: 'ai-component',
  encapsulation: ViewEncapsulation.None, // Required for Tailwind
  template: `
    <div class="ai-component-wrapper">
      <!-- Scoped classes with component prefix -->
    </div>
  `,
})
export class ComponentName {}
```

### Dynamic Classes Pattern (cn utility)

```typescript
import { cn } from '@angular-ai-kit/utils';

classes = computed(() => {
  return cn(
    'base-class another-class',
    {
      'conditional-class': this.condition(),
      'active:ring-2': this.isActive(),
    },
    this.customClasses() // Allow class override from parent
  );
});
```

### CSS Custom Properties (Theming)

```css
/* theme.css */
@layer base {
  :root {
    --ai-primary: theme('colors.blue.600');
    --ai-text: theme('colors.gray.900');
    --ai-background: theme('colors.white');
  }

  .dark {
    --ai-primary: theme('colors.blue.400');
    --ai-text: theme('colors.gray.100');
    --ai-background: theme('colors.gray.900');
  }
}
```

### Tailwind @layer Pattern

```css
/* component.css (if needed) */
@layer components {
  .ai-message-bubble {
    @apply rounded-lg px-4 py-3 shadow-sm;
  }
}

@layer utilities {
  .ai-scrollbar-thin {
    scrollbar-width: thin;
  }
}
```

## Accessibility Requirements

- It MUST pass all AXE checks
- It MUST follow all WCAG AA minimums, including focus management, color contrast, and ARIA attributes
- Always include ARIA labels where needed
- Ensure keyboard navigation works
- Use semantic HTML elements
- Maintain proper focus management
- Test with screen readers (when possible)

### Host Bindings for Accessibility

```typescript
@Component({
  selector: 'ai-component',
  host: {
    '[class.active]': 'isActive()',
    '[attr.aria-label]': 'label()',
    '(click)': 'handleClick()',
    '(keydown.enter)': 'handleEnter()',
  },
})
export class ComponentName {
  // Use host object instead of @HostBinding/@HostListener
}
```

## AI Component Specific Rules

### Chat Components

- Always support both user and assistant messages
- Include copy functionality for assistant messages
- Support streaming text display
- Handle empty states gracefully

### Input Components

- Support keyboard shortcuts (Enter to submit, Shift+Enter for new line)
- Include loading/disabled states
- Validate inputs when appropriate
- Provide clear feedback

### Display Components

- Support markdown rendering
- Include syntax highlighting for code
- Provide copy-to-clipboard functionality
- Handle long content (scrolling, truncation)

### Control Components

- Emit clear events
- Support disabled states
- Provide visual feedback
- Maintain state properly

## File Organization & Architecture

### Component Structure

```text
packages/angular-ai-kit/src/lib/
├── components/
│   ├── chat/
│   │   ├── message-bubble/
│   │   │   ├── message-bubble.component.ts (max 500 lines)
│   │   │   ├── message-bubble.types.ts (if complex types)
│   │   │   └── index.ts (barrel export)
│   │   ├── message-list/
│   │   └── chat-container/
│   ├── input/
│   │   ├── prompt-input/
│   │   └── file-upload/
│   └── display/
│       ├── code-block/
│       └── markdown-renderer/
├── directives/
│   ├── copy-to-clipboard.directive.ts
│   ├── auto-resize.directive.ts
│   └── index.ts
├── services/
│   ├── chat.service.ts (abstract)
│   ├── streaming.service.ts (abstract)
│   └── index.ts
├── types/
│   ├── chat-message.types.ts
│   ├── model.types.ts
│   └── index.ts
├── tokens/
│   ├── chat.tokens.ts
│   └── index.ts
└── index.ts (public API)
```

### Naming Conventions

- **Components:** `kebab-case.component.ts` (e.g., `message-bubble.component.ts`)
- **Directives:** `kebab-case.directive.ts` (e.g., `copy-to-clipboard.directive.ts`)
- **Services:** `kebab-case.service.ts` (e.g., `chat.service.ts`)
- **Types:** `kebab-case.types.ts` (e.g., `chat-message.types.ts`)
- **Utils:** `kebab-case.ts` (e.g., `token-counter.ts`)
- **Barrel exports:** `index.ts` in each folder

### File Size Limits

- **Maximum 500 lines per file**
- If a file exceeds 500 lines, refactor by:
  - Extracting helper functions to separate files
  - Splitting complex components into smaller ones
  - Moving types to `.types.ts` files
  - Creating utility functions in `@angular-ai-kit/utils`

## What NOT to Do

- ❌ Don't use NgModules
- ❌ Don't set `standalone: true` (it's default in Angular v20+)
- ❌ Don't use `@HostBinding` and `@HostListener` decorators (use `host` object instead)
- ❌ Don't use `ngClass` (use `class` bindings instead)
- ❌ Don't use `ngStyle` (use `style` bindings instead)
- ❌ Don't use `mutate` on signals (use `update` or `set` instead)
- ❌ Don't use constructor injection (use `inject()` function instead)
- ❌ Don't assume globals like `new Date()` are available in templates
- ❌ Don't write arrow functions in templates
- ❌ Don't use RxJS unless absolutely necessary (prefer signals, use toSignal/toObservable for interop)
- ❌ Don't use Zone.js-dependent features
- ❌ **NEVER use SCSS - ONLY CSS**
- ❌ Don't use ViewEncapsulation.Emulated or ShadowDom (use ViewEncapsulation.None for Tailwind)
- ❌ Don't access DOM directly (use Renderer2 or inject(DOCUMENT) for SSR compatibility)
- ❌ Don't create components that aren't AI-focused
- ❌ Don't add unnecessary dependencies
- ❌ Don't write tests (as per project requirements)
- ❌ Don't use ChangeDetectionStrategy.Default
- ❌ Don't create non-standalone components
- ❌ Don't use template-driven forms (prefer Reactive forms)
- ❌ Don't add features outside the scope of Phase 0
- ❌ Don't forget SSR/hydration compatibility
- ❌ Don't ignore accessibility (ARIA, keyboard nav, screen readers)

## Code Review Checklist

Before considering code complete:

- [ ] Uses standalone components (without explicit `standalone: true`)
- [ ] Uses signal-based inputs/outputs (input(), output(), computed())
- [ ] Uses `inject()` function for services (no constructor injection)
- [ ] OnPush change detection
- [ ] ViewEncapsulation.None for Tailwind compatibility
- [ ] No `ngClass` or `ngStyle` (uses class/style bindings instead)
- [ ] No `@HostBinding` or `@HostListener` (uses `host` object)
- [ ] No `mutate` on signals (uses `update` or `set`)
- [ ] Uses CSS only (no SCSS)
- [ ] Uses Tailwind utility classes (utility-first approach)
- [ ] Uses `cn()` utility for dynamic classes
- [ ] Uses CSS custom properties for theming
- [ ] SSR/Hydration compatible (no direct DOM access, uses inject(DOCUMENT))
- [ ] Passes AXE accessibility checks
- [ ] Follows WCAG AA minimums
- [ ] Keyboard navigation works (Tab, Enter, Escape, Arrows)
- [ ] ARIA labels and roles properly set
- [ ] Focus management implemented
- [ ] Supports prefers-reduced-motion
- [ ] Dark mode support via CSS variables
- [ ] No unnecessary dependencies
- [ ] Responsive design (mobile-first)
- [ ] Touch targets minimum 44x44px
- [ ] Clean, readable code
- [ ] Proper TypeScript types (no `any`, use `unknown` if needed)
- [ ] No console.logs or debug code
- [ ] JSDoc comments for public APIs
- [ ] Follows file organization structure
- [ ] Input transforms used where appropriate
- [ ] Allows customClasses input for override
- [ ] Error states handled gracefully

## Questions to Ask

When implementing a component:

1. Is this component AI-focused?
2. Does it use signals and OnPush?
3. Is it accessible?
4. Is it responsive?
5. Does it follow the established patterns?
6. Is the code clean and maintainable?

## Git Conventions

### Commit Messages

- Use clear, descriptive messages
- Format: `feat: add MessageBubble component`
- Types: `feat`, `fix`, `docs`, `style`, `refactor`, `chore`

### Branch Naming

- `feature/component-name`
- `fix/issue-description`
- `docs/update-readme`

## Dependencies

- Only add dependencies when absolutely necessary
- Prefer peer dependencies for Angular packages
- Keep bundle size minimal
- Document why each dependency is needed

## Documentation

- Add JSDoc comments for public APIs
- Include usage examples in component files
- Document inputs, outputs, and methods
- Explain complex logic

## Performance

- Use OnPush change detection
- Minimize effect() usage
- Use computed() for derived state
- Avoid unnecessary re-renders
- Optimize bundle size

## Nx Monorepo Guidelines

- This project uses Nx workspace for managing multiple projects (library, demo app, CLI, docs)
- Use Nx generators to create new libraries/apps: `nx g @nx/angular:lib libs/libName` (or `nx generate @nx/angular:lib libs/libName`)
- Use Nx commands for building: `nx build <project-name>`
- Leverage Nx affected commands for CI/CD: `nx affected -t build`, `nx affected -t lint` (or use `nx run-many -t build --all` for all projects)
- Enforce module boundaries to prevent circular dependencies
- Use `nx graph` to visualize project dependencies
- Configure proper tsconfig paths: `@angular-ai-kit/core`, `@angular-ai-kit/tokens`, `@angular-ai-kit/utils`
- Reference: [Nx Angular Documentation](https://nx.dev/docs/technologies/angular)

## Advanced Angular Patterns

### Input Transforms

```typescript
// Coerce boolean inputs (handle both boolean and empty string)
disabled = input(false, {
  transform: (value: boolean | string) => value === '' || value === true,
});

// Transform string to number
count = input(0, {
  transform: (value: string | number) =>
    typeof value === 'string' ? parseInt(value, 10) : value,
});
```

### Content Projection

```typescript
@Component({
  selector: 'ai-card',
  template: `
    <div class="ai-card">
      <div class="ai-card-header">
        <ng-content select="[header]" />
      </div>
      <div class="ai-card-body">
        <ng-content />
      </div>
      <div class="ai-card-footer">
        <ng-content select="[footer]" />
      </div>
    </div>
  `,
})
export class CardComponent {}
```

### Host Directives (Composition)

```typescript
// Reusable directive
@Directive({
  selector: '[aiCopyToClipboard]',
  host: {
    '(click)': 'copy()',
  },
})
export class CopyToClipboardDirective {
  text = input.required<string>();

  private clipboard = inject(Clipboard);

  copy() {
    this.clipboard.copy(this.text());
  }
}

// Compose into component
@Component({
  selector: 'ai-code-block',
  hostDirectives: [
    {
      directive: CopyToClipboardDirective,
      inputs: ['text'],
    },
  ],
})
export class CodeBlockComponent {}
```

### RxJS Interop (Signals + Observables)

```typescript
import { toSignal, toObservable } from '@angular/core/rxjs-interop';

export class StreamingComponent {
  // Observable to Signal
  private streamService = inject(StreamingService);
  streamData = toSignal(this.streamService.stream$, { initialValue: '' });

  // Signal to Observable (for integration with RxJS operators)
  message = signal('');
  message$ = toObservable(this.message);
}
```

### Resource API (Async Loading)

```typescript
import { rxResource } from '@angular/core/rxjs-interop';

export class ChatComponent {
  conversationId = input.required<string>();

  // Async resource that reloads when conversationId changes
  conversation = rxResource({
    request: () => ({ id: this.conversationId() }),
    loader: ({ request }) => this.chatService.getConversation(request.id),
  });

  // Template usage
  // @if (conversation.value(); as conv) { ... }
  // @if (conversation.isLoading()) { <spinner /> }
  // @if (conversation.error(); as error) { <error-message /> }
}
```

### SSR/Hydration Safe DOM Access

```typescript
import { isPlatformBrowser } from '@angular/common';
import { PLATFORM_ID, Renderer2, inject } from '@angular/core';

export class ComponentWithDOM {
  private platformId = inject(PLATFORM_ID);
  private renderer = inject(Renderer2);
  private document = inject(DOCUMENT);

  scrollToBottom() {
    if (isPlatformBrowser(this.platformId)) {
      const element = this.document.querySelector('.chat-container');
      if (element) {
        this.renderer.setProperty(element, 'scrollTop', element.scrollHeight);
      }
    }
  }
}
```

---

_These rules should guide all development in this project. When in doubt, prioritize Angular v21 best practices and signal-based reactivity._
